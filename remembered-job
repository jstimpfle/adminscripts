#!/bin/sh

##
## remembered-job -- Register jobs for a number of hosts and execute them in a
## script(1) session.
##
## This file is part of adminscripts (https://github.com/jstimpfle/adminscripts)
## Copyright (C) 2013, Jens Stimpfle <debian@jstimpfle.de>
##
##
## Notable dependencies: Needs a recent script(1) (normally from bsdutils
## package) which supports the -e option.

usage() {
	cat >&2 <<'EOF'
Usage:
    remembered-job new <jobname> [-once] <shell-cmd>
    remembered-job add <jobname> <host> [<host>...]
    remembered-job run <jobname> [<host>...]
    remembered-job lsh <jobname>
    remembered-job rmh <jobname> [--purge] <host> [<host>...]
    remembered-job lsj
    remembered-job rmj <jobname> [-f|--force]
EOF
	exit 1
}

perror() {
	printf %s\\n "remembered-job: $*" >&2
}

p() {
	printf %s\\n "$*" >&2
}

shell_escape() {
	printf %s\\n "$1" | sed -e 's/[^a-zA-Z0-9_+-]/\\&/g; $!s/$/\\/'
}

job_must_exist() {
	if ! [ -d "$jobdir" ]; then
		perror "Job does not exist: $job"
		exit 1
	fi
	if ! [ -d "$jobdir"/queue \
	    -a -d "$jobdir"/results \
	    -a -f "$jobdir"/command ]; then
		perror "Error: Job directories/files not properly set up."
		exit 1
	fi
}

task_new() (
	if [ -d "$jobdir" ]; then
		perror "Can't create: job exists"
		exit 1
	fi

	if [ $# = 2 ]; then
		once=false
		command=$2
	elif [ $# = 3 -a "$2" = -once ]; then
		once=true
		command=$3
	else
		usage
	fi

	mkdir "$jobdir" "$jobdir"/queue "$jobdir"/results \
	&& if $once ; then touch "$jobdir"/once ; fi \
	&& printf %s\\n "$command" > "$jobdir"/command \

	if [ $? -ne 0 ]; then
		perror "Failed to create all files for $job. (Some files may be left)"
		exit 1
	fi
)

task_add() (
	[ $# -ge 2 ] || usage
	shift

	job_must_exist

	retval=0
	for i in "$@"; do
		if [ -e "$jobdir"/results/"$i" ]; then
			perror "$i already added to $job; not adding."
			continue
		fi

		if ! mkdir "$jobdir"/results/"$i" \
		   || ! date '+Added %F %T' > "$jobdir"/queue/"$i"; then
			perror "Errors occurred while adding $i to $job."
			retval=1
		fi
	done
	return $retval
)

run_one() (
	arg=$1
	argdir=$jobdir/results/$arg

	if ! cd "$argdir"; then
		perror "not running $1: could not cd into $argdir."
		exit 1
	fi

	if ! mkdir lock; then
		if [ -d lock ]; then
			perror "Lock directory $argdir/lock exists already. If you are sure the job is not running, remove it manually and retry."
		else
			perror "Failed to create lock directory $argdir/lock"
		fi
		perror "Not running job '$job' with argument '$arg' due to previous errors"
		exit 1
	fi
	trap "rmdir lock" EXIT

	dir=1; while [ -d "$argdir/$dir" ]; do dir=$((dir + 1)); done

	if ! mkdir "$dir" || ! ln -f -s -T "$dir" last; then
		perror "Failed to run $job for $i: Errors while creating run environment."
		exit 1;
	fi

	if ! cd "$dir"; then
		perror "Not running job '$job' with argument '$arg' due to previous errors"
	fi
	trap "rmdir ../lock" EXIT

	cmd_e=$(shell_escape "$jobdir/command")
	arg_e=$(shell_escape "$arg")
	script -e -c "sh -- $cmd_e $arg_e" -ttimings typescript
	ests=$?

	if [ $ests -ne 0 ]; then
		echo "Exitstatus $ests" > failed
		exit "$ests"
	fi

	if [ -f "$jobdir"/once ]; then
		rm "$jobdir"/queue/"$arg" || exit
	fi

	> success
)

task_run() (
	[ $# -ge 1 ] || usage
	shift

	job_must_exist

	if [ $# -eq 0 ]; then
		for i in "$jobdir"/queue/*; do
			[ -f "$i" ] || continue
			set -- "$@" "${i##*/}"
		done
	else
		for i in "$@"; do
			if ! [ -f "$jobdir"/queue/"$i" ]; then
				perror "$i is not scheduled for $job."
				exit 1
			fi
			set -- "$@" "$i"
			shift
		done
	fi

	if [ $# -eq 0 ]; then
		p "Nothing to do."
		exit 0
	fi

	for i in "$@" ; do
		run_one "$i" || exit
	done
)

task_lsh() (
	[ $# -eq 1 ] || usage
	job_must_exist
	LS_COLORS=never ls "$jobdir"/queue
)

task_lsj() (
	LS_COLORS=never ls "$rj_dir"
)

task_rmh() (
	shift
	[ "$1" = --purge ] && purge=true && shift || purge=false
	[ $# -ge 1 ] || usage

	job_must_exist
	for i in "$@"; do
		if [ ! -f "$jobdir"/queue/"$i" ]; then
			perror "Can't remove $i: Not registered for job $job"
			continue
		fi
		rm "$jobdir"/queue/"$i"
		if $purge; then
			rm -r "$jobdir"/results/"$i"
		fi
	done
)

task_rmj() (
	shift
	case $1 in
	-f|--force)
		force=true
		shift
		;;
	*)
		force=false
		;;
	esac

	[ $# -eq 0 ] || usage
	job_must_exist
	if ! $force && tty >/dev/null; then
		while true; do
			p "Delete job $job? Please type 'yes' or 'no'"
			read answer
			case $answer in
			yes)
				break
				;;
			no)
				p 'Aborted by request'
				exit 0
			esac
		done
	fi
	rm -rf "$jobdir"
)

case $1 in
	new|add|run|lsh|lsj|rmh|rmj)
		;;
	*)
		perror "Unknown command: $1"
		usage
		;;
esac

rj_dir=~/remembered_jobs

if ! [ -d "$rj_dir" ]; then
	perror "$rj_dir does not exist (or is not a directory). Aborting."
	exit 1
fi

job=$2
jobdir=$rj_dir/$job

task=task_$1
shift
"$task" "$@"
